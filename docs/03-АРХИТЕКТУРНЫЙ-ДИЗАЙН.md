# АРХИТЕКТУРНЫЙ ДИЗАЙН
## Проект: CurRate Go Rewrite

**Версия:** 1.0
**Дата:** 19 декабря 2025

---

## 1. ОБЗОР АРХИТЕКТУРЫ

### 1.1. Архитектурный паттерн

**Model-View-Controller (MVC) с разделением на слои**

```
┌─────────────────────────────────────────────┐
│              USER INTERFACE                 │
│         (GUI - Walk framework)              │
└──────────────┬──────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────┐
│           CONTROLLER LAYER                  │
│      (Event Handlers, Data Binding)         │
└──────────────┬──────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────┐
│          BUSINESS LOGIC LAYER               │
│  (Currency Converter, Validators)           │
└──────────────┬──────────────────────────────┘
               │
           ┌───┴───┐
           ▼       ▼
    ┌──────────┐  ┌──────────┐
    │  CACHE   │  │  PARSER  │
    │  LAYER   │  │  LAYER   │
    └──────────┘  └────┬─────┘
                       │
                       ▼
                 ┌───────────┐
                 │   HTTP    │
                 │  CLIENT   │
                 └───────────┘
```

### 1.2. Принципы проектирования

- **Separation of Concerns** - каждый модуль отвечает за свою функциональность
- **Dependency Injection** - передача зависимостей через конструкторы
- **Interface Segregation** - использование интерфейсов для абстракции
- **Single Responsibility** - один модуль = одна ответственность
- **Don't Repeat Yourself (DRY)** - переиспользование кода

---

## 2. СТРУКТУРА ПРОЕКТА

### 2.1. Файловая структура

```
currate-go/
│
├── cmd/
│   └── currate/
│       └── main.go              # Точка входа приложения
│
├── internal/                    # Приватный код (не экспортируется)
│   │
│   ├── gui/                     # GUI слой
│   │   ├── window.go            # Главное окно приложения
│   │   ├── callbacks.go         # Event handlers
│   │   └── formatters.go        # Форматирование для отображения
│   │
│   ├── converter/               # Бизнес-логика конвертации
│   │   ├── converter.go         # Основной конвертер
│   │   ├── validator.go         # Валидация входных данных
│   │   └── formatter.go         # Форматирование результата
│   │
│   ├── parser/                  # Парсинг ЦБ РФ
│   │   ├── cbr.go               # Парсер сайта ЦБ РФ
│   │   ├── client.go            # HTTP клиент
│   │   ├── retry.go             # Retry логика
│   │   └── errors.go            # Кастомные ошибки
│   │
│   ├── cache/                   # Кэширование
│   │   ├── lru.go               # LRU кэш
│   │   └── entry.go             # Структура записи кэша
│   │
│   └── models/                  # Модели данных
│       ├── currency.go          # Структуры для валют
│       └── rate.go              # Структура курса
│
├── pkg/                         # Публичный код (если нужен)
│   └── utils/                   # Утилиты общего назначения
│       └── number.go            # Парсинг чисел
│
├── docs/                        # Документация
│   ├── 01-ТЕХНИЧЕСКОЕ-ЗАДАНИЕ.md
│   ├── 02-ТЕХНОЛОГИЧЕСКИЙ-СТЕК.md
│   ├── 03-АРХИТЕКТУРНЫЙ-ДИЗАЙН.md
│   ├── 04-ПЛАН-РАЗРАБОТКИ.md
│   └── 05-МИГРАЦИЯ-PYTHON-GO.md
│
├── .gitignore
├── .golangci.yml                # Конфигурация линтера
├── go.mod                       # Зависимости
├── go.sum                       # Checksums
├── README.md
└── LICENSE
```

### 2.2. Размер и scope файлов

| Файл | Строк кода | Ответственность |
|------|------------|-----------------|
| `main.go` | ~50 | Инициализация и запуск |
| `gui/window.go` | ~300-400 | UI декларация и setup |
| `gui/callbacks.go` | ~200-300 | Event handlers |
| `converter/converter.go` | ~200 | Конвертация валют |
| `parser/cbr.go` | ~250 | Парсинг HTML |
| `cache/lru.go` | ~150 | LRU кэш |
| **ИТОГО** | **~1500-2000** | |

---

## 3. ДЕТАЛЬНЫЙ ДИЗАЙН МОДУЛЕЙ

### 3.1. Module: `main.go`

**Ответственность:** Точка входа, инициализация приложения

```go
package main

import (
    "github.com/bivlked/currate-go/internal/cache"
    "github.com/bivlked/currate-go/internal/converter"
    "github.com/bivlked/currate-go/internal/gui"
    "github.com/bivlked/currate-go/internal/parser"
)

func main() {
    // Инициализация компонентов
    cacheInstance := cache.NewLRUCache(100, 24*time.Hour)
    httpClient := parser.NewHTTPClient(10 * time.Second)
    cbrParser := parser.NewCBRParser(httpClient)
    currencyConverter := converter.NewConverter(cbrParser, cacheInstance)

    // Запуск GUI
    gui.Run(currencyConverter)
}
```

**Зависимости:**
- `internal/gui`
- `internal/converter`
- `internal/parser`
- `internal/cache`

---

### 3.2. Module: `internal/models`

**Ответственность:** Определение структур данных

#### `models/currency.go`

```go
package models

// Currency - код валюты
type Currency string

const (
    USD Currency = "USD"
    EUR Currency = "EUR"
)

// Validate проверяет, что валюта поддерживается
func (c Currency) Validate() error {
    switch c {
    case USD, EUR:
        return nil
    default:
        return ErrUnsupportedCurrency
    }
}

// Symbol возвращает символ валюты ($, €)
func (c Currency) Symbol() string {
    switch c {
    case USD:
        return "$"
    case EUR:
        return "€"
    default:
        return ""
    }
}
```

#### `models/rate.go`

```go
package models

import "time"

// ExchangeRate - курс валюты на дату
type ExchangeRate struct {
    Currency Currency
    Date     time.Time
    Rate     float64   // Курс за 1 единицу валюты
}

// ConversionResult - результат конвертации
type ConversionResult struct {
    Amount       float64  // Исходная сумма
    Currency     Currency // Исходная валюта
    Rate         float64  // Использованный курс
    ResultRUB    float64  // Результат в рублях
    FormattedStr string   // Отформатированная строка для отображения
}
```

---

### 3.3. Module: `internal/parser`

**Ответственность:** Получение курсов с сайта ЦБ РФ

#### `parser/client.go`

```go
package parser

import (
    "net/http"
    "time"
)

// HTTPClient - обертка над http.Client
type HTTPClient struct {
    client *http.Client
}

// NewHTTPClient создает новый HTTP клиент с таймаутом
func NewHTTPClient(timeout time.Duration) *HTTPClient {
    return &HTTPClient{
        client: &http.Client{
            Timeout: timeout,
            Transport: &http.Transport{
                MaxIdleConns:       10,
                IdleConnTimeout:    30 * time.Second,
                DisableCompression: false,
            },
        },
    }
}

// Get выполняет GET запрос
func (c *HTTPClient) Get(url string) (*http.Response, error) {
    return c.client.Get(url)
}
```

#### `parser/cbr.go`

```go
package parser

import (
    "fmt"
    "strconv"
    "strings"
    "time"

    "github.com/PuerkitoBio/goquery"
    "github.com/bivlked/currate-go/internal/models"
)

// CBRParser - парсер сайта ЦБ РФ
type CBRParser struct {
    client *HTTPClient
    retry  *RetryStrategy
}

// NewCBRParser создает новый парсер
func NewCBRParser(client *HTTPClient) *CBRParser {
    return &CBRParser{
        client: client,
        retry:  NewRetryStrategy(3, 1*time.Second),
    }
}

// GetRate получает курс валюты на дату
func (p *CBRParser) GetRate(currency models.Currency, date time.Time) (float64, error) {
    url := p.buildURL(date)

    var lastErr error
    for i := 0; i < p.retry.MaxAttempts; i++ {
        rate, err := p.fetchRate(url, currency)
        if err == nil {
            return rate, nil
        }
        lastErr = err

        if i < p.retry.MaxAttempts-1 {
            time.Sleep(p.retry.BackoffDuration(i))
        }
    }

    return 0, fmt.Errorf("failed after %d attempts: %w", p.retry.MaxAttempts, lastErr)
}

func (p *CBRParser) buildURL(date time.Time) string {
    dateStr := date.Format("02.01.2006")
    return fmt.Sprintf("https://cbr.ru/currency_base/daily/?UniDbQuery.Posted=True&UniDbQuery.To=%s", dateStr)
}

func (p *CBRParser) fetchRate(url string, currency models.Currency) (float64, error) {
    resp, err := p.client.Get(url)
    if err != nil {
        return 0, &NetworkError{Err: err}
    }
    defer resp.Body.Close()

    if resp.StatusCode != 200 {
        return 0, &HTTPError{StatusCode: resp.StatusCode}
    }

    doc, err := goquery.NewDocumentFromReader(resp.Body)
    if err != nil {
        return 0, &ParseError{Err: err}
    }

    return p.parseTable(doc, currency)
}

func (p *CBRParser) parseTable(doc *goquery.Document, currency models.Currency) (float64, error) {
    table := doc.Find("table.data")
    if table.Length() == 0 {
        return 0, &ParseError{Message: "table.data not found"}
    }

    var rate float64
    var nominal int
    found := false

    table.Find("tr").Each(func(i int, row *goquery.Selection) {
        if found {
            return
        }

        cols := row.Find("td")
        if cols.Length() < 5 {
            return
        }

        // Код валюты в столбце 2 (индекс 1)
        currencyCode := strings.TrimSpace(cols.Eq(1).Text())
        if currencyCode != string(currency) {
            return
        }

        // Номинал в столбце 3 (индекс 2)
        nominalStr := strings.TrimSpace(cols.Eq(2).Text())
        nominal, _ = strconv.Atoi(nominalStr)

        // Курс в столбце 5 (индекс 4)
        rateStr := strings.TrimSpace(cols.Eq(4).Text())
        rateStr = strings.ReplaceAll(rateStr, ",", ".")
        rate, _ = strconv.ParseFloat(rateStr, 64)

        found = true
    })

    if !found {
        return 0, &CurrencyNotFoundError{Currency: currency}
    }

    // Возвращаем курс за 1 единицу валюты
    return rate / float64(nominal), nil
}
```

#### `parser/retry.go`

```go
package parser

import "time"

// RetryStrategy - стратегия повторов
type RetryStrategy struct {
    MaxAttempts   int
    BaseDelay     time.Duration
}

// NewRetryStrategy создает новую стратегию
func NewRetryStrategy(maxAttempts int, baseDelay time.Duration) *RetryStrategy {
    return &RetryStrategy{
        MaxAttempts: maxAttempts,
        BaseDelay:   baseDelay,
    }
}

// BackoffDuration возвращает задержку для попытки i (экспоненциальная)
func (r *RetryStrategy) BackoffDuration(attempt int) time.Duration {
    return r.BaseDelay * time.Duration(1<<uint(attempt)) // 1s, 2s, 4s
}
```

#### `parser/errors.go`

```go
package parser

import (
    "fmt"
    "github.com/bivlked/currate-go/internal/models"
)

// NetworkError - ошибка сети
type NetworkError struct {
    Err error
}

func (e *NetworkError) Error() string {
    return fmt.Sprintf("network error: %v", e.Err)
}

func (e *NetworkError) UserMessage() string {
    return "Не удалось подключиться к серверу ЦБ РФ. Проверьте подключение к интернету."
}

// HTTPError - HTTP ошибка
type HTTPError struct {
    StatusCode int
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d", e.StatusCode)
}

func (e *HTTPError) UserMessage() string {
    return fmt.Sprintf("Ошибка HTTP: %d", e.StatusCode)
}

// ParseError - ошибка парсинга
type ParseError struct {
    Err     error
    Message string
}

func (e *ParseError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("parse error: %v", e.Err)
    }
    return fmt.Sprintf("parse error: %s", e.Message)
}

func (e *ParseError) UserMessage() string {
    return "Ошибка при обработке данных с сервера. Попробуйте другую дату."
}

// CurrencyNotFoundError - валюта не найдена
type CurrencyNotFoundError struct {
    Currency models.Currency
}

func (e *CurrencyNotFoundError) Error() string {
    return fmt.Sprintf("currency %s not found", e.Currency)
}

func (e *CurrencyNotFoundError) UserMessage() string {
    return "Курс валюты не найден для указанной даты."
}
```

---

### 3.4. Module: `internal/cache`

**Ответственность:** LRU кэш для курсов валют

#### `cache/lru.go`

```go
package cache

import (
    "container/list"
    "sync"
    "time"

    "github.com/bivlked/currate-go/internal/models"
)

// LRUCache - потокобезопасный LRU кэш
type LRUCache struct {
    mu       sync.RWMutex
    cache    map[string]*list.Element
    lru      *list.List
    maxSize  int
    ttl      time.Duration
}

// Entry - запись в кэше
type Entry struct {
    key       string
    rate      float64
    timestamp time.Time
}

// NewLRUCache создает новый LRU кэш
func NewLRUCache(maxSize int, ttl time.Duration) *LRUCache {
    return &LRUCache{
        cache:   make(map[string]*list.Element),
        lru:     list.New(),
        maxSize: maxSize,
        ttl:     ttl,
    }
}

// Get получает курс из кэша
func (c *LRUCache) Get(currency models.Currency, date time.Time) (float64, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()

    key := c.makeKey(currency, date)
    elem, exists := c.cache[key]
    if !exists {
        return 0, false
    }

    entry := elem.Value.(*Entry)

    // Проверка TTL
    if time.Since(entry.timestamp) > c.ttl {
        c.lru.Remove(elem)
        delete(c.cache, key)
        return 0, false
    }

    // Переместить в конец (LRU)
    c.lru.MoveToBack(elem)
    return entry.rate, true
}

// Set сохраняет курс в кэш
func (c *LRUCache) Set(currency models.Currency, date time.Time, rate float64) {
    c.mu.Lock()
    defer c.mu.Unlock()

    key := c.makeKey(currency, date)

    // Если уже существует - обновить
    if elem, exists := c.cache[key]; exists {
        entry := elem.Value.(*Entry)
        entry.rate = rate
        entry.timestamp = time.Now()
        c.lru.MoveToBack(elem)
        return
    }

    // Вытеснение если переполнен
    if c.lru.Len() >= c.maxSize {
        oldest := c.lru.Front()
        if oldest != nil {
            c.lru.Remove(oldest)
            delete(c.cache, oldest.Value.(*Entry).key)
        }
    }

    // Добавить новую запись
    entry := &Entry{
        key:       key,
        rate:      rate,
        timestamp: time.Now(),
    }
    elem := c.lru.PushBack(entry)
    c.cache[key] = elem
}

func (c *LRUCache) makeKey(currency models.Currency, date time.Time) string {
    return string(currency) + ":" + date.Format("2006-01-02")
}

// Size возвращает текущий размер кэша
func (c *LRUCache) Size() int {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.lru.Len()
}

// Clear очищает весь кэш
func (c *LRUCache) Clear() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.cache = make(map[string]*list.Element)
    c.lru.Init()
}
```

---

### 3.5. Module: `internal/converter`

**Ответственность:** Бизнес-логика конвертации

#### `converter/converter.go`

```go
package converter

import (
    "time"

    "github.com/bivlked/currate-go/internal/models"
    "github.com/bivlked/currate-go/internal/parser"
    "github.com/bivlked/currate-go/internal/cache"
)

// Converter - конвертер валют
type Converter struct {
    parser *parser.CBRParser
    cache  *cache.LRUCache
}

// NewConverter создает новый конвертер
func NewConverter(parser *parser.CBRParser, cache *cache.LRUCache) *Converter {
    return &Converter{
        parser: parser,
        cache:  cache,
    }
}

// Convert конвертирует валюту в рубли
func (c *Converter) Convert(amount float64, currency models.Currency, date time.Time) (*models.ConversionResult, error) {
    // Валидация
    if err := ValidateAmount(amount); err != nil {
        return nil, err
    }
    if err := currency.Validate(); err != nil {
        return nil, err
    }
    if err := ValidateDate(date); err != nil {
        return nil, err
    }

    // Получение курса (сначала из кэша)
    rate, found := c.cache.Get(currency, date)
    if !found {
        var err error
        rate, err = c.parser.GetRate(currency, date)
        if err != nil {
            return nil, err
        }
        c.cache.Set(currency, date, rate)
    }

    // Конвертация
    resultRUB := amount * rate

    // Форматирование
    formatted := FormatResult(amount, rate, currency, resultRUB)

    return &models.ConversionResult{
        Amount:       amount,
        Currency:     currency,
        Rate:         rate,
        ResultRUB:    resultRUB,
        FormattedStr: formatted,
    }, nil
}
```

#### `converter/validator.go`

```go
package converter

import (
    "errors"
    "time"
)

var (
    ErrInvalidAmount      = errors.New("сумма должна быть положительным числом")
    ErrDateInFuture       = errors.New("дата не может быть в будущем")
    ErrInvalidDateFormat  = errors.New("некорректный формат даты. Используйте DD.MM.YYYY")
)

// ValidateAmount проверяет корректность суммы
func ValidateAmount(amount float64) error {
    if amount <= 0 {
        return ErrInvalidAmount
    }
    return nil
}

// ValidateDate проверяет корректность даты
func ValidateDate(date time.Time) error {
    if date.After(time.Now()) {
        return ErrDateInFuture
    }
    return nil
}
```

#### `converter/formatter.go`

```go
package converter

import (
    "fmt"
    "strings"

    "github.com/bivlked/currate-go/internal/models"
)

// FormatResult форматирует результат конвертации
func FormatResult(amount, rate float64, currency models.Currency, resultRUB float64) string {
    // Форматирование с разделителями тысяч и запятой
    resultStr := formatNumber(resultRUB)
    amountStr := formatNumber(amount)
    rateStr := fmt.Sprintf("%.4f", rate)
    rateStr = strings.ReplaceAll(rateStr, ".", ",")

    symbol := currency.Symbol()

    return fmt.Sprintf("%s руб. (%s%s по курсу %s)",
        resultStr, symbol, amountStr, rateStr)
}

// formatNumber форматирует число с разделителями тысяч (пробел) и запятой
func formatNumber(num float64) string {
    str := fmt.Sprintf("%.2f", num)
    str = strings.ReplaceAll(str, ".", ",")

    // Разделение на целую и дробную части
    parts := strings.Split(str, ",")
    intPart := parts[0]
    decPart := parts[1]

    // Добавление разделителей тысяч
    intPart = addThousandsSeparator(intPart)

    return intPart + "," + decPart
}

func addThousandsSeparator(s string) string {
    if len(s) <= 3 {
        return s
    }

    var result strings.Builder
    for i, c := range s {
        if i > 0 && (len(s)-i)%3 == 0 {
            result.WriteString(" ")
        }
        result.WriteRune(c)
    }
    return result.String()
}
```

---

### 3.6. Module: `internal/gui`

**Ответственность:** Графический интерфейс

#### `gui/window.go`

```go
package gui

import (
    "time"

    "github.com/lxn/walk"
    . "github.com/lxn/walk/declarative"

    "github.com/bivlked/currate-go/internal/converter"
    "github.com/bivlked/currate-go/internal/models"
)

// AppWindow - главное окно приложения
type AppWindow struct {
    *walk.MainWindow
    converter     *converter.Converter

    dateEdit      *walk.DateEdit
    usdRadio      *walk.RadioButton
    eurRadio      *walk.RadioButton
    amountEdit    *walk.LineEdit
    convertBtn    *walk.PushButton
    copyBtn       *walk.PushButton
    resultLabel   *walk.Label
}

// Run запускает GUI приложение
func Run(conv *converter.Converter) error {
    app := &AppWindow{converter: conv}

    return MainWindow{
        AssignTo: &app.MainWindow,
        Title:    "Конвертер валют (с) BiV 2024 г.",
        MinSize:  Size{Width: 340, Height: 455},
        Size:     Size{Width: 340, Height: 455},
        Layout:   VBox{},
        Children: []Widget{
            app.createDateSection(),
            app.createCurrencySection(),
            app.createAmountSection(),
            app.createButtonsSection(),
            app.createResultSection(),
        },
    }.Create()
}

// Методы создания секций UI...
// (см. следующие части документа)
```

---

## 4. ДИАГРАММЫ

### 4.1. Диаграмма последовательности: Конвертация валюты

```
User → GUI → Converter → Cache → Parser → CBR.ru

1. Пользователь нажимает "Конвертировать"
   GUI.OnConvert()

2. GUI → Converter.Convert(amount, currency, date)

3. Converter → Validator.ValidateAmount(amount)
   Validator → Converter: OK

4. Converter → Cache.Get(currency, date)

5a. Если в кэше:
    Cache → Converter: rate

5b. Если НЕ в кэше:
    Cache → Converter: not found
    Converter → Parser.GetRate(currency, date)
    Parser → HTTPClient.Get(url)
    HTTPClient → CBR.ru: HTTP GET
    CBR.ru → HTTPClient: HTML
    Parser.parseTable(HTML)
    Parser → Converter: rate
    Converter → Cache.Set(currency, date, rate)

6. Converter: result = amount * rate
   Converter.FormatResult(result)
   Converter → GUI: ConversionResult

7. GUI.UpdateResultLabel(result)
   GUI → User: Отображение результата
```

### 4.2. Диаграмма состояний GUI

```
[Idle] ─(User enters data)→ [Ready to Convert]
  ↓                                ↓
  └──────────────────────────────────→ (Click Convert)
                                       ↓
                              [Loading...] ─(Success)→ [Result Displayed]
                                  ↓                            ↓
                              (Error)                  (Click Copy)
                                  ↓                            ↓
                          [Error Displayed]            [Copied to Clipboard]
                                  ↓                            ↓
                          (User corrects)              (User changes data)
                                  ↓                            ↓
                              [Ready to Convert] ←────────────┘
```

---

## 5. ИНТЕРФЕЙСЫ И КОНТРАКТЫ

### 5.1. Interface: RateProvider

```go
// RateProvider - интерфейс для получения курсов
type RateProvider interface {
    GetRate(currency models.Currency, date time.Time) (float64, error)
}
```

**Реализации:**
- `parser.CBRParser` - реальный парсер ЦБ РФ
- `MockRateProvider` (для тестов) - мок для unit-тестов

### 5.2. Interface: CacheStorage

```go
// CacheStorage - интерфейс для кэша
type CacheStorage interface {
    Get(currency models.Currency, date time.Time) (float64, bool)
    Set(currency models.Currency, date time.Time, rate float64)
    Clear()
}
```

**Реализации:**
- `cache.LRUCache` - реальный LRU кэш
- `cache.NoOpCache` - пустая заглушка (для отладки)

---

## 6. КОНФИГУРАЦИЯ И КОНСТАНТЫ

### 6.1. Константы приложения

```go
package config

const (
    AppName    = "CurRate"
    AppVersion = "1.0.0"
    AppAuthor  = "BiV"
    AppYear    = "2024"

    // Кэш
    CacheMaxSize = 100
    CacheTTL     = 24 * time.Hour

    // HTTP
    HTTPTimeout       = 10 * time.Second
    HTTPMaxRetries    = 3
    HTTPRetryBaseDelay = 1 * time.Second

    // GUI
    WindowWidth  = 340
    WindowHeight = 455
)
```

---

## 7. ТЕСТИРОВАНИЕ

### 7.1. Стратегия тестирования

**Unit тесты:**
- `converter` - тестирование логики конвертации
- `parser` - мокирование HTTP, тестирование парсинга
- `cache` - тестирование LRU алгоритма
- `validator` - тестирование валидации

**Integration тесты:**
- Реальные запросы к cbr.ru (с пометкой `-short` для пропуска)
- Тестирование связки Converter + Parser + Cache

**GUI тесты:**
- Пропустить в v1.0 (сложно тестировать Walk)

### 7.2. Пример теста

```go
func TestConverter_Convert(t *testing.T) {
    mockParser := &MockRateProvider{
        rate: 85.5,
    }
    cache := cache.NewLRUCache(100, 24*time.Hour)
    conv := converter.NewConverter(mockParser, cache)

    result, err := conv.Convert(1000, models.USD, time.Now())

    assert.NoError(t, err)
    assert.Equal(t, 85500.0, result.ResultRUB)
}
```

---

**Конец документа**

**Подготовлено:** Ivan Bondarev (BiV)
**Дата:** 19.12.2025
